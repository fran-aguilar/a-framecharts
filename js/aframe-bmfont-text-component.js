!function (t) { function r(n) { if (e[n]) return e[n].exports; var i = e[n] = { exports: {}, id: n, loaded: !1 }; return t[n].call(i.exports, i, i.exports, r), i.loaded = !0, i.exports } var e = {}; return r.m = t, r.c = e, r.p = "", r(0) }([function (t, r, e) { function n(t, r) { o(t.font, function (e, n) { if (e) throw e; var i = new THREE.TextureLoader; i.load(t.image, function (t) { r(n, t) }) }) } if ("undefined" == typeof AFRAME) throw new Error("Component attempted to register before AFRAME was available."); var i = e(33), o = e(22), a = e(8); e(7), AFRAME.registerComponent("bmfont-text", { schema: { text: { type: "string" }, width: { type: "number", "default": 1e3 }, align: { type: "string", "default": "left" }, letterSpacing: { type: "number", "default": 0 }, lineHeight: { type: "number", "default": 38 }, fnt: { type: "string", "default": "https://cdn.rawgit.com/bryik/aframe-bmfont-text-component/aa0655cf90f646e12c40ab4708ea90b4686cfb45/assets/DejaVu-sdf.fnt" }, fntImage: { type: "string", "default": "https://cdn.rawgit.com/bryik/aframe-bmfont-text-component/aa0655cf90f646e12c40ab4708ea90b4686cfb45/assets/DejaVu-sdf.png" }, mode: { type: "string", "default": "normal" }, color: { type: "color", "default": "white" }, opacity: { type: "number", "default": "1.0" } }, update: function (t) { function r(t, r) { r.needsUpdate = !0, r.anisotropy = 16; var n = { font: t, text: o.text, width: o.width, align: o.align, letterSpacing: o.letterSpacing, lineHeight: o.lineHeight, mode: o.mode }, u = i(n), f = new THREE.RawShaderMaterial(a({ map: r, side: THREE.DoubleSide, transparent: !0, color: o.color, opacity: o.opacity })), s = new THREE.Mesh(u, f); s.rotation.y = Math.PI, s.scale.multiplyScalar(-.005), e.setObject3D("bmfont-text", s) } var e = this.el, o = this.data; n({ font: o.fnt, image: o.fntImage }, r) }, remove: function () { this.el.removeObject3D("bmfont-text") } }) }, function (t, r, e) {
    (function (t, n) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
        "use strict"; function i() { try { var t = new Uint8Array(1); return t.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength } catch (r) { return !1 } } function o() { return t.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function a(r, e) { if (o() < e) throw new RangeError("Invalid typed array length"); return t.TYPED_ARRAY_SUPPORT ? (r = new Uint8Array(e), r.__proto__ = t.prototype) : (null === r && (r = new t(e)), r.length = e), r } function t(r, e, n) { if (!(t.TYPED_ARRAY_SUPPORT || this instanceof t)) return new t(r, e, n); if ("number" == typeof r) { if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string"); return h(this, r) } return u(this, r, e, n) } function u(t, r, e, n) { if ("number" == typeof r) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? p(t, r, e, n) : "string" == typeof r ? c(t, r, e) : g(t, r) } function f(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function s(t, r, e, n) { return f(r), r <= 0 ? a(t, r) : void 0 !== e ? "string" == typeof n ? a(t, r).fill(e, n) : a(t, r).fill(e) : a(t, r) } function h(r, e) { if (f(e), r = a(r, e < 0 ? 0 : 0 | d(e)), !t.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n) r[n] = 0; return r } function c(r, e, n) { if ("string" == typeof n && "" !== n || (n = "utf8"), !t.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var i = 0 | v(e, n); r = a(r, i); var o = r.write(e, n); return o !== i && (r = r.slice(0, o)), r } function l(t, r) { var e = r.length < 0 ? 0 : 0 | d(r.length); t = a(t, e); for (var n = 0; n < e; n += 1) t[n] = 255 & r[n]; return t } function p(r, e, n, i) { if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (e.byteLength < n + (i || 0)) throw new RangeError("'length' is out of bounds"); return e = void 0 === n && void 0 === i ? new Uint8Array(e) : void 0 === i ? new Uint8Array(e, n) : new Uint8Array(e, n, i), t.TYPED_ARRAY_SUPPORT ? (r = e, r.__proto__ = t.prototype) : r = l(r, e), r } function g(r, e) { if (t.isBuffer(e)) { var n = 0 | d(e.length); return r = a(r, n), 0 === r.length ? r : (e.copy(r, 0, 0, n), r) } if (e) { if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || Z(e.length) ? a(r, 0) : l(r, e); if ("Buffer" === e.type && Q(e.data)) return l(r, e.data) } throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") } function d(t) { if (t >= o()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes"); return 0 | t } function y(r) { return +r != r && (r = 0), t.alloc(+r) } function v(r, e) { if (t.isBuffer(r)) return r.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(r) || r instanceof ArrayBuffer)) return r.byteLength; "string" != typeof r && (r = "" + r); var n = r.length; if (0 === n) return 0; for (var i = !1; ;) switch (e) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return z(r).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return J(r).length; default: if (i) return z(r).length; e = ("" + e).toLowerCase(), i = !0 } } function w(t, r, e) { var n = !1; if ((void 0 === r || r < 0) && (r = 0), r > this.length) return ""; if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return ""; if (e >>>= 0, r >>>= 0, e <= r) return ""; for (t || (t = "utf8") ; ;) switch (t) { case "hex": return M(this, r, e); case "utf8": case "utf-8": return U(this, r, e); case "ascii": return I(this, r, e); case "latin1": case "binary": return O(this, r, e); case "base64": return S(this, r, e); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return C(this, r, e); default: if (n) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), n = !0 } } function m(t, r, e) { var n = t[r]; t[r] = t[e], t[e] = n } function b(r, e, n, i, o) { if (0 === r.length) return -1; if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : r.length - 1), n < 0 && (n = r.length + n), n >= r.length) { if (o) return -1; n = r.length - 1 } else if (n < 0) { if (!o) return -1; n = 0 } if ("string" == typeof e && (e = t.from(e, i)), t.isBuffer(e)) return 0 === e.length ? -1 : E(r, e, n, i, o); if ("number" == typeof e) return e = 255 & e, t.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(r, e, n) : Uint8Array.prototype.lastIndexOf.call(r, e, n) : E(r, [e], n, i, o); throw new TypeError("val must be string, number or Buffer") } function E(t, r, e, n, i) { function o(t, r) { return 1 === a ? t[r] : t.readUInt16BE(r * a) } var a = 1, u = t.length, f = r.length; if (void 0 !== n && (n = String(n).toLowerCase(), "ucs2" === n || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) { if (t.length < 2 || r.length < 2) return -1; a = 2, u /= 2, f /= 2, e /= 2 } var s; if (i) { var h = -1; for (s = e; s < u; s++) if (o(t, s) === o(r, h === -1 ? 0 : s - h)) { if (h === -1 && (h = s), s - h + 1 === f) return h * a } else h !== -1 && (s -= s - h), h = -1 } else for (e + f > u && (e = u - f), s = e; s >= 0; s--) { for (var c = !0, l = 0; l < f; l++) if (o(t, s + l) !== o(r, l)) { c = !1; break } if (c) return s } return -1 } function A(t, r, e, n) { e = Number(e) || 0; var i = t.length - e; n ? (n = Number(n), n > i && (n = i)) : n = i; var o = r.length; if (o % 2 !== 0) throw new TypeError("Invalid hex string"); n > o / 2 && (n = o / 2); for (var a = 0; a < n; ++a) { var u = parseInt(r.substr(2 * a, 2), 16); if (isNaN(u)) return a; t[e + a] = u } return a } function _(t, r, e, n) { return W(z(r, t.length - e), t, e, n) } function R(t, r, e, n) { return W(G(r), t, e, n) } function x(t, r, e, n) { return R(t, r, e, n) } function T(t, r, e, n) { return W(J(r), t, e, n) } function B(t, r, e, n) { return W(V(r, t.length - e), t, e, n) } function S(t, r, e) { return 0 === r && e === t.length ? $.fromByteArray(t) : $.fromByteArray(t.slice(r, e)) } function U(t, r, e) { e = Math.min(t.length, e); for (var n = [], i = r; i < e;) { var o = t[i], a = null, u = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1; if (i + u <= e) { var f, s, h, c; switch (u) { case 1: o < 128 && (a = o); break; case 2: f = t[i + 1], 128 === (192 & f) && (c = (31 & o) << 6 | 63 & f, c > 127 && (a = c)); break; case 3: f = t[i + 1], s = t[i + 2], 128 === (192 & f) && 128 === (192 & s) && (c = (15 & o) << 12 | (63 & f) << 6 | 63 & s, c > 2047 && (c < 55296 || c > 57343) && (a = c)); break; case 4: f = t[i + 1], s = t[i + 2], h = t[i + 3], 128 === (192 & f) && 128 === (192 & s) && 128 === (192 & h) && (c = (15 & o) << 18 | (63 & f) << 12 | (63 & s) << 6 | 63 & h, c > 65535 && c < 1114112 && (a = c)) } } null === a ? (a = 65533, u = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += u } return P(n) } function P(t) { var r = t.length; if (r <= tt) return String.fromCharCode.apply(String, t); for (var e = "", n = 0; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += tt)); return e } function I(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]); return n } function O(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]); return n } function M(t, r, e) { var n = t.length; (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n); for (var i = "", o = r; o < e; ++o) i += q(t[o]); return i } function C(t, r, e) { for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]); return i } function L(t, r, e) { if (t % 1 !== 0 || t < 0) throw new RangeError("offset is not uint"); if (t + r > e) throw new RangeError("Trying to access beyond buffer length") } function Y(r, e, n, i, o, a) { if (!t.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > o || e < a) throw new RangeError('"value" argument is out of bounds'); if (n + i > r.length) throw new RangeError("Index out of range") } function k(t, r, e, n) { r < 0 && (r = 65535 + r + 1); for (var i = 0, o = Math.min(t.length - e, 2) ; i < o; ++i) t[e + i] = (r & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i) } function D(t, r, e, n) { r < 0 && (r = 4294967295 + r + 1); for (var i = 0, o = Math.min(t.length - e, 4) ; i < o; ++i) t[e + i] = r >>> 8 * (n ? i : 3 - i) & 255 } function j(t, r, e, n, i, o) { if (e + n > t.length) throw new RangeError("Index out of range"); if (e < 0) throw new RangeError("Index out of range") } function H(t, r, e, n, i) { return i || j(t, r, e, 4, 3.4028234663852886e38, -3.4028234663852886e38), K.write(t, r, e, n, 23, 4), e + 4 } function N(t, r, e, n, i) { return i || j(t, r, e, 8, 1.7976931348623157e308, -1.7976931348623157e308), K.write(t, r, e, n, 52, 8), e + 8 } function F(t) { if (t = X(t).replace(rt, ""), t.length < 2) return ""; for (; t.length % 4 !== 0;) t += "="; return t } function X(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") } function q(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function z(t, r) { r = r || 1 / 0; for (var e, n = t.length, i = null, o = [], a = 0; a < n; ++a) { if (e = t.charCodeAt(a), e > 55295 && e < 57344) { if (!i) { if (e > 56319) { (r -= 3) > -1 && o.push(239, 191, 189); continue } if (a + 1 === n) { (r -= 3) > -1 && o.push(239, 191, 189); continue } i = e; continue } if (e < 56320) { (r -= 3) > -1 && o.push(239, 191, 189), i = e; continue } e = (i - 55296 << 10 | e - 56320) + 65536 } else i && (r -= 3) > -1 && o.push(239, 191, 189); if (i = null, e < 128) { if ((r -= 1) < 0) break; o.push(e) } else if (e < 2048) { if ((r -= 2) < 0) break; o.push(e >> 6 | 192, 63 & e | 128) } else if (e < 65536) { if ((r -= 3) < 0) break; o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128) } else { if (!(e < 1114112)) throw new Error("Invalid code point"); if ((r -= 4) < 0) break; o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128) } } return o } function G(t) { for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e)); return r } function V(t, r) { for (var e, n, i, o = [], a = 0; a < t.length && !((r -= 2) < 0) ; ++a) e = t.charCodeAt(a), n = e >> 8, i = e % 256, o.push(i), o.push(n); return o } function J(t) { return $.toByteArray(F(t)) } function W(t, r, e, n) { for (var i = 0; i < n && !(i + e >= r.length || i >= t.length) ; ++i) r[i + e] = t[i]; return i } function Z(t) { return t !== t } var $ = e(24), K = e(4), Q = e(25); r.Buffer = t, r.SlowBuffer = y, r.INSPECT_MAX_BYTES = 50, t.TYPED_ARRAY_SUPPORT = void 0 !== n.TYPED_ARRAY_SUPPORT ? n.TYPED_ARRAY_SUPPORT : i(), r.kMaxLength = o(), t.poolSize = 8192, t._augment = function (r) { return r.__proto__ = t.prototype, r }, t.from = function (t, r, e) { return u(null, t, r, e) }, t.TYPED_ARRAY_SUPPORT && (t.prototype.__proto__ = Uint8Array.prototype, t.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && t[Symbol.species] === t && Object.defineProperty(t, Symbol.species, { value: null, configurable: !0 })), t.alloc = function (t, r, e) { return s(null, t, r, e) }, t.allocUnsafe = function (t) { return h(null, t) }, t.allocUnsafeSlow = function (t) { return h(null, t) }, t.isBuffer = function (t) { return !(null == t || !t._isBuffer) }, t.compare = function (r, e) { if (!t.isBuffer(r) || !t.isBuffer(e)) throw new TypeError("Arguments must be Buffers"); if (r === e) return 0; for (var n = r.length, i = e.length, o = 0, a = Math.min(n, i) ; o < a; ++o) if (r[o] !== e[o]) { n = r[o], i = e[o]; break } return n < i ? -1 : i < n ? 1 : 0 }, t.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, t.concat = function (r, e) { if (!Q(r)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === r.length) return t.alloc(0); var n; if (void 0 === e) for (e = 0, n = 0; n < r.length; ++n) e += r[n].length; var i = t.allocUnsafe(e), o = 0; for (n = 0; n < r.length; ++n) { var a = r[n]; if (!t.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers'); a.copy(i, o), o += a.length } return i }, t.byteLength = v, t.prototype._isBuffer = !0, t.prototype.swap16 = function () { var t = this.length; if (t % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var r = 0; r < t; r += 2) m(this, r, r + 1); return this }, t.prototype.swap32 = function () { var t = this.length; if (t % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var r = 0; r < t; r += 4) m(this, r, r + 3), m(this, r + 1, r + 2); return this }, t.prototype.swap64 = function () { var t = this.length; if (t % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var r = 0; r < t; r += 8) m(this, r, r + 7), m(this, r + 1, r + 6), m(this, r + 2, r + 5), m(this, r + 3, r + 4); return this }, t.prototype.toString = function () { var t = 0 | this.length; return 0 === t ? "" : 0 === arguments.length ? U(this, 0, t) : w.apply(this, arguments) }, t.prototype.equals = function (r) { if (!t.isBuffer(r)) throw new TypeError("Argument must be a Buffer"); return this === r || 0 === t.compare(this, r) }, t.prototype.inspect = function () { var t = "", e = r.INSPECT_MAX_BYTES; return this.length > 0 && (t = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (t += " ... ")), "<Buffer " + t + ">" }, t.prototype.compare = function (r, e, n, i, o) { if (!t.isBuffer(r)) throw new TypeError("Argument must be a Buffer"); if (void 0 === e && (e = 0), void 0 === n && (n = r ? r.length : 0), void 0 === i && (i = 0), void 0 === o && (o = this.length), e < 0 || n > r.length || i < 0 || o > this.length) throw new RangeError("out of range index"); if (i >= o && e >= n) return 0; if (i >= o) return -1; if (e >= n) return 1; if (e >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === r) return 0; for (var a = o - i, u = n - e, f = Math.min(a, u), s = this.slice(i, o), h = r.slice(e, n), c = 0; c < f; ++c) if (s[c] !== h[c]) { a = s[c], u = h[c]; break } return a < u ? -1 : u < a ? 1 : 0 }, t.prototype.includes = function (t, r, e) { return this.indexOf(t, r, e) !== -1 }, t.prototype.indexOf = function (t, r, e) { return b(this, t, r, e, !0) }, t.prototype.lastIndexOf = function (t, r, e) { return b(this, t, r, e, !1) }, t.prototype.write = function (t, r, e, n) { if (void 0 === r) n = "utf8", e = this.length, r = 0; else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0; else { if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); r = 0 | r, isFinite(e) ? (e = 0 | e, void 0 === n && (n = "utf8")) : (n = e, e = void 0) } var i = this.length - r; if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); for (var o = !1; ;) switch (n) { case "hex": return A(this, t, r, e); case "utf8": case "utf-8": return _(this, t, r, e); case "ascii": return R(this, t, r, e); case "latin1": case "binary": return x(this, t, r, e); case "base64": return T(this, t, r, e); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return B(this, t, r, e); default: if (o) throw new TypeError("Unknown encoding: " + n); n = ("" + n).toLowerCase(), o = !0 } }, t.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var tt = 4096; t.prototype.slice = function (r, e) { var n = this.length; r = ~~r, e = void 0 === e ? n : ~~e, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), e < r && (e = r); var i; if (t.TYPED_ARRAY_SUPPORT) i = this.subarray(r, e), i.__proto__ = t.prototype; else { var o = e - r; i = new t(o, (void 0)); for (var a = 0; a < o; ++a) i[a] = this[a + r] } return i }, t.prototype.readUIntLE = function (t, r, e) { t = 0 | t, r = 0 | r, e || L(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256) ;) n += this[t + o] * i; return n }, t.prototype.readUIntBE = function (t, r, e) { t = 0 | t, r = 0 | r, e || L(t, r, this.length); for (var n = this[t + --r], i = 1; r > 0 && (i *= 256) ;) n += this[t + --r] * i; return n }, t.prototype.readUInt8 = function (t, r) { return r || L(t, 1, this.length), this[t] }, t.prototype.readUInt16LE = function (t, r) { return r || L(t, 2, this.length), this[t] | this[t + 1] << 8 }, t.prototype.readUInt16BE = function (t, r) { return r || L(t, 2, this.length), this[t] << 8 | this[t + 1] }, t.prototype.readUInt32LE = function (t, r) { return r || L(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, t.prototype.readUInt32BE = function (t, r) { return r || L(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, t.prototype.readIntLE = function (t, r, e) { t = 0 | t, r = 0 | r, e || L(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256) ;) n += this[t + o] * i; return i *= 128, n >= i && (n -= Math.pow(2, 8 * r)), n }, t.prototype.readIntBE = function (t, r, e) { t = 0 | t, r = 0 | r, e || L(t, r, this.length); for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256) ;) o += this[t + --n] * i; return i *= 128, o >= i && (o -= Math.pow(2, 8 * r)), o }, t.prototype.readInt8 = function (t, r) { return r || L(t, 1, this.length), 128 & this[t] ? (255 - this[t] + 1) * -1 : this[t] }, t.prototype.readInt16LE = function (t, r) { r || L(t, 2, this.length); var e = this[t] | this[t + 1] << 8; return 32768 & e ? 4294901760 | e : e }, t.prototype.readInt16BE = function (t, r) { r || L(t, 2, this.length); var e = this[t + 1] | this[t] << 8; return 32768 & e ? 4294901760 | e : e }, t.prototype.readInt32LE = function (t, r) { return r || L(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, t.prototype.readInt32BE = function (t, r) { return r || L(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, t.prototype.readFloatLE = function (t, r) { return r || L(t, 4, this.length), K.read(this, t, !0, 23, 4) }, t.prototype.readFloatBE = function (t, r) { return r || L(t, 4, this.length), K.read(this, t, !1, 23, 4) }, t.prototype.readDoubleLE = function (t, r) { return r || L(t, 8, this.length), K.read(this, t, !0, 52, 8) }, t.prototype.readDoubleBE = function (t, r) { return r || L(t, 8, this.length), K.read(this, t, !1, 52, 8) }, t.prototype.writeUIntLE = function (t, r, e, n) { if (t = +t, r = 0 | r, e = 0 | e, !n) { var i = Math.pow(2, 8 * e) - 1; Y(this, t, r, e, i, 0) } var o = 1, a = 0; for (this[r] = 255 & t; ++a < e && (o *= 256) ;) this[r + a] = t / o & 255; return r + e }, t.prototype.writeUIntBE = function (t, r, e, n) { if (t = +t, r = 0 | r, e = 0 | e, !n) { var i = Math.pow(2, 8 * e) - 1; Y(this, t, r, e, i, 0) } var o = e - 1, a = 1; for (this[r + o] = 255 & t; --o >= 0 && (a *= 256) ;) this[r + o] = t / a & 255; return r + e }, t.prototype.writeUInt8 = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 1, 255, 0), t.TYPED_ARRAY_SUPPORT || (r = Math.floor(r)), this[e] = 255 & r, e + 1 }, t.prototype.writeUInt16LE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 2, 65535, 0), t.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & r, this[e + 1] = r >>> 8) : k(this, r, e, !0), e + 2 }, t.prototype.writeUInt16BE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 2, 65535, 0), t.TYPED_ARRAY_SUPPORT ? (this[e] = r >>> 8, this[e + 1] = 255 & r) : k(this, r, e, !1), e + 2 }, t.prototype.writeUInt32LE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 4, 4294967295, 0), t.TYPED_ARRAY_SUPPORT ? (this[e + 3] = r >>> 24, this[e + 2] = r >>> 16, this[e + 1] = r >>> 8, this[e] = 255 & r) : D(this, r, e, !0), e + 4 }, t.prototype.writeUInt32BE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 4, 4294967295, 0), t.TYPED_ARRAY_SUPPORT ? (this[e] = r >>> 24, this[e + 1] = r >>> 16, this[e + 2] = r >>> 8, this[e + 3] = 255 & r) : D(this, r, e, !1), e + 4 }, t.prototype.writeIntLE = function (t, r, e, n) { if (t = +t, r = 0 | r, !n) { var i = Math.pow(2, 8 * e - 1); Y(this, t, r, e, i - 1, -i) } var o = 0, a = 1, u = 0; for (this[r] = 255 & t; ++o < e && (a *= 256) ;) t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / a >> 0) - u & 255; return r + e }, t.prototype.writeIntBE = function (t, r, e, n) { if (t = +t, r = 0 | r, !n) { var i = Math.pow(2, 8 * e - 1); Y(this, t, r, e, i - 1, -i) } var o = e - 1, a = 1, u = 0; for (this[r + o] = 255 & t; --o >= 0 && (a *= 256) ;) t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / a >> 0) - u & 255; return r + e }, t.prototype.writeInt8 = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 1, 127, -128), t.TYPED_ARRAY_SUPPORT || (r = Math.floor(r)), r < 0 && (r = 255 + r + 1), this[e] = 255 & r, e + 1 }, t.prototype.writeInt16LE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 2, 32767, -32768), t.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & r, this[e + 1] = r >>> 8) : k(this, r, e, !0), e + 2 }, t.prototype.writeInt16BE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 2, 32767, -32768), t.TYPED_ARRAY_SUPPORT ? (this[e] = r >>> 8, this[e + 1] = 255 & r) : k(this, r, e, !1), e + 2 }, t.prototype.writeInt32LE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 4, 2147483647, -2147483648), t.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & r, this[e + 1] = r >>> 8, this[e + 2] = r >>> 16, this[e + 3] = r >>> 24) : D(this, r, e, !0), e + 4 }, t.prototype.writeInt32BE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), t.TYPED_ARRAY_SUPPORT ? (this[e] = r >>> 24, this[e + 1] = r >>> 16, this[e + 2] = r >>> 8, this[e + 3] = 255 & r) : D(this, r, e, !1), e + 4 }, t.prototype.writeFloatLE = function (t, r, e) { return H(this, t, r, !0, e) }, t.prototype.writeFloatBE = function (t, r, e) { return H(this, t, r, !1, e) }, t.prototype.writeDoubleLE = function (t, r, e) { return N(this, t, r, !0, e) }, t.prototype.writeDoubleBE = function (t, r, e) { return N(this, t, r, !1, e) }, t.prototype.copy = function (r, e, n, i) { if (n || (n = 0), i || 0 === i || (i = this.length), e >= r.length && (e = r.length), e || (e = 0), i > 0 && i < n && (i = n), i === n) return 0; if (0 === r.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (i < 0) throw new RangeError("sourceEnd out of bounds"); i > this.length && (i = this.length), r.length - e < i - n && (i = r.length - e + n); var o, a = i - n; if (this === r && n < e && e < i) for (o = a - 1; o >= 0; --o) r[o + e] = this[o + n]; else if (a < 1e3 || !t.TYPED_ARRAY_SUPPORT) for (o = 0; o < a; ++o) r[o + e] = this[o + n]; else Uint8Array.prototype.set.call(r, this.subarray(n, n + a), e); return a }, t.prototype.fill = function (r, e, n, i) { if ("string" == typeof r) { if ("string" == typeof e ? (i = e, e = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), 1 === r.length) { var o = r.charCodeAt(0); o < 256 && (r = o) } if (void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string"); if ("string" == typeof i && !t.isEncoding(i)) throw new TypeError("Unknown encoding: " + i) } else "number" == typeof r && (r = 255 & r); if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index"); if (n <= e) return this; e >>>= 0, n = void 0 === n ? this.length : n >>> 0, r || (r = 0); var a; if ("number" == typeof r) for (a = e; a < n; ++a) this[a] = r; else { var u = t.isBuffer(r) ? r : z(new t(r, i).toString()), f = u.length; for (a = 0; a < n - e; ++a) this[a + e] = u[a % f] } return this }; var rt = /[^+\/0-9A-Za-z-_]/g
    }).call(r, e(1).Buffer, function () { return this }())
}, function (t, r) { function e() { for (var t = {}, r = 0; r < arguments.length; r++) { var e = arguments[r]; for (var i in e) n.call(e, i) && (t[i] = e[i]) } return t } t.exports = e; var n = Object.prototype.hasOwnProperty }, function (t, r) { t.exports = function (t) { switch (t) { case "int8": return Int8Array; case "int16": return Int16Array; case "int32": return Int32Array; case "uint8": return Uint8Array; case "uint16": return Uint16Array; case "uint32": return Uint32Array; case "float32": return Float32Array; case "float64": return Float64Array; case "array": return Array; case "uint8_clamped": return Uint8ClampedArray } } }, function (t, r) { r.read = function (t, r, e, n, i) { var o, a, u = 8 * i - n - 1, f = (1 << u) - 1, s = f >> 1, h = -7, c = e ? i - 1 : 0, l = e ? -1 : 1, p = t[r + c]; for (c += l, o = p & (1 << -h) - 1, p >>= -h, h += u; h > 0; o = 256 * o + t[r + c], c += l, h -= 8); for (a = o & (1 << -h) - 1, o >>= -h, h += n; h > 0; a = 256 * a + t[r + c], c += l, h -= 8); if (0 === o) o = 1 - s; else { if (o === f) return a ? NaN : (p ? -1 : 1) * (1 / 0); a += Math.pow(2, n), o -= s } return (p ? -1 : 1) * a * Math.pow(2, o - n) }, r.write = function (t, r, e, n, i, o) { var a, u, f, s = 8 * o - i - 1, h = (1 << s) - 1, c = h >> 1, l = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, g = n ? 1 : -1, d = r < 0 || 0 === r && 1 / r < 0 ? 1 : 0; for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (u = isNaN(r) ? 1 : 0, a = h) : (a = Math.floor(Math.log(r) / Math.LN2), r * (f = Math.pow(2, -a)) < 1 && (a--, f *= 2), r += a + c >= 1 ? l / f : l * Math.pow(2, 1 - c), r * f >= 2 && (a++, f /= 2), a + c >= h ? (u = 0, a = h) : a + c >= 1 ? (u = (r * f - 1) * Math.pow(2, i), a += c) : (u = r * Math.pow(2, c - 1) * Math.pow(2, i), a = 0)) ; i >= 8; t[e + p] = 255 & u, p += g, u /= 256, i -= 8); for (a = a << i | u, s += i; s > 0; t[e + p] = 255 & a, p += g, a /= 256, s -= 8); t[e + p - g] |= 128 * d } }, function (t, r) { function e(t) { var r = n.call(t); return "[object Function]" === r || "function" == typeof t && "[object RegExp]" !== r || "undefined" != typeof window && (t === window.setTimeout || t === window.alert || t === window.confirm || t === window.prompt) } t.exports = e; var n = Object.prototype.toString }, function (t, r) { "use strict"; function e(t) { if (null === t || void 0 === t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } function n() { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var r = {}, e = 0; e < 10; e++) r["_" + String.fromCharCode(e)] = e; var n = Object.getOwnPropertyNames(r).map(function (t) { return r[t] }); if ("0123456789" !== n.join("")) return !1; var i = {}; return "abcdefghijklmnopqrst".split("").forEach(function (t) { i[t] = t }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, i)).join("") } catch (o) { return !1 } } var i = Object.prototype.hasOwnProperty, o = Object.prototype.propertyIsEnumerable; t.exports = n() ? Object.assign : function (t, r) { for (var n, a, u = e(t), f = 1; f < arguments.length; f++) { n = Object(arguments[f]); for (var s in n) i.call(n, s) && (u[s] = n[s]); if (Object.getOwnPropertySymbols) { a = Object.getOwnPropertySymbols(n); for (var h = 0; h < a.length; h++) o.call(n, a[h]) && (u[a[h]] = n[a[h]]) } } return u } }, function (t, r) { var e = AFRAME.utils.extendDeep, n = AFRAME.primitives.getMeshMixin(); AFRAME.registerPrimitive("a-text", e({}, n, { defaultComponents: { "bmfont-text": {} }, mappings: { text: "bmfont-text.text", width: "bmfont-text.width", align: "bmfont-text.align", letterSpacing: "bmfont-text.letterSpacing", lineHeight: "bmfont-text.lineHeight", fnt: "bmfont-text.fnt", fntImage: "bmfont-text.fntImage", mode: "bmfont-text.mode", color: "bmfont-text.color", opacity: "bmfont-text.opacity" } })) }, function (t, r, e) { var n = e(6); t.exports = function (t) { t = t || {}; var r = "number" == typeof t.opacity ? t.opacity : 1, e = "number" == typeof t.alphaTest ? t.alphaTest : 1e-4, i = t.precision || "highp", o = t.color, a = t.map; return delete t.map, delete t.color, delete t.precision, delete t.opacity, n({ uniforms: { opacity: { type: "f", value: r }, map: { type: "t", value: a || new THREE.Texture }, color: { type: "c", value: new THREE.Color(o) } }, vertexShader: ["attribute vec2 uv;", "attribute vec4 position;", "uniform mat4 projectionMatrix;", "uniform mat4 modelViewMatrix;", "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * position;", "}"].join("\n"), fragmentShader: ["#ifdef GL_OES_standard_derivatives", "#extension GL_OES_standard_derivatives : enable", "#endif", "precision " + i + " float;", "uniform float opacity;", "uniform vec3 color;", "uniform sampler2D map;", "varying vec2 vUv;", "float aastep(float value) {", "  #ifdef GL_OES_standard_derivatives", "    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;", "  #else", "    float afwidth = (1.0 / 32.0) * (1.4142135623730951 / (2.0 * gl_FragCoord.w));", "  #endif", "  return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);", "}", "void main() {", "  vec4 texColor = texture2D(map, vUv);", "  float alpha = aastep(texColor.a);", "  gl_FragColor = vec4(color, opacity * alpha);", 0 === e ? "" : "  if (gl_FragColor.a < " + e + ") discard;", "}"].join("\n") }, t) } }, function (t, r) { function e(t) { return t.BYTES_PER_ELEMENT && "[object ArrayBuffer]" === n.call(t.buffer) || Array.isArray(t) } var n = Object.prototype.toString; t.exports = e }, function (t, r) { t.exports = function (t, r) { return "number" == typeof t ? t : "number" == typeof r ? r : 0 } }, function (t, r) { "use strict"; function e() { for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0, e = t.length; r < e; ++r) u[r] = t[r], f[t.charCodeAt(r)] = r; f["-".charCodeAt(0)] = 62, f["_".charCodeAt(0)] = 63 } function n(t) { var r, e, n, i, o, a, u = t.length; if (u % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); o = "=" === t[u - 2] ? 2 : "=" === t[u - 1] ? 1 : 0, a = new s(3 * u / 4 - o), n = o > 0 ? u - 4 : u; var h = 0; for (r = 0, e = 0; r < n; r += 4, e += 3) i = f[t.charCodeAt(r)] << 18 | f[t.charCodeAt(r + 1)] << 12 | f[t.charCodeAt(r + 2)] << 6 | f[t.charCodeAt(r + 3)], a[h++] = i >> 16 & 255, a[h++] = i >> 8 & 255, a[h++] = 255 & i; return 2 === o ? (i = f[t.charCodeAt(r)] << 2 | f[t.charCodeAt(r + 1)] >> 4, a[h++] = 255 & i) : 1 === o && (i = f[t.charCodeAt(r)] << 10 | f[t.charCodeAt(r + 1)] << 4 | f[t.charCodeAt(r + 2)] >> 2, a[h++] = i >> 8 & 255, a[h++] = 255 & i), a } function i(t) { return u[t >> 18 & 63] + u[t >> 12 & 63] + u[t >> 6 & 63] + u[63 & t] } function o(t, r, e) { for (var n, o = [], a = r; a < e; a += 3) n = (t[a] << 16) + (t[a + 1] << 8) + t[a + 2], o.push(i(n)); return o.join("") } function a(t) { for (var r, e = t.length, n = e % 3, i = "", a = [], f = 16383, s = 0, h = e - n; s < h; s += f) a.push(o(t, s, s + f > h ? h : s + f)); return 1 === n ? (r = t[e - 1], i += u[r >> 2], i += u[r << 4 & 63], i += "==") : 2 === n && (r = (t[e - 2] << 8) + t[e - 1], i += u[r >> 10], i += u[r >> 4 & 63], i += u[r << 2 & 63], i += "="), a.push(i), a.join("") } r.toByteArray = n, r.fromByteArray = a; var u = [], f = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array; e() }, function (t, r, e) { var n = e(13).Buffer; t.exports = function (t, r) { if (n.isBuffer(t) && n.isBuffer(r)) { if ("function" == typeof t.equals) return t.equals(r); if (t.length !== r.length) return !1; for (var e = 0; e < t.length; e++) if (t[e] !== r[e]) return !1; return !0 } } }, function (t, r, e) {
    (function (t, n) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
        "use strict"; function i() { try { var t = new Uint8Array(1); return t.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength } catch (r) { return !1 } } function o() { return t.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function a(r, e) { if (o() < e) throw new RangeError("Invalid typed array length"); return t.TYPED_ARRAY_SUPPORT ? (r = new Uint8Array(e), r.__proto__ = t.prototype) : (null === r && (r = new t(e)), r.length = e), r } function t(r, e, n) { if (!(t.TYPED_ARRAY_SUPPORT || this instanceof t)) return new t(r, e, n); if ("number" == typeof r) { if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string"); return h(this, r) } return u(this, r, e, n) } function u(t, r, e, n) { if ("number" == typeof r) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? p(t, r, e, n) : "string" == typeof r ? c(t, r, e) : g(t, r) } function f(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function s(t, r, e, n) { return f(r), r <= 0 ? a(t, r) : void 0 !== e ? "string" == typeof n ? a(t, r).fill(e, n) : a(t, r).fill(e) : a(t, r) } function h(r, e) { if (f(e), r = a(r, e < 0 ? 0 : 0 | d(e)), !t.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n) r[n] = 0; return r } function c(r, e, n) { if ("string" == typeof n && "" !== n || (n = "utf8"), !t.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var i = 0 | v(e, n); r = a(r, i); var o = r.write(e, n); return o !== i && (r = r.slice(0, o)), r } function l(t, r) { var e = r.length < 0 ? 0 : 0 | d(r.length); t = a(t, e); for (var n = 0; n < e; n += 1) t[n] = 255 & r[n]; return t } function p(r, e, n, i) { if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (e.byteLength < n + (i || 0)) throw new RangeError("'length' is out of bounds"); return e = void 0 === n && void 0 === i ? new Uint8Array(e) : void 0 === i ? new Uint8Array(e, n) : new Uint8Array(e, n, i), t.TYPED_ARRAY_SUPPORT ? (r = e, r.__proto__ = t.prototype) : r = l(r, e), r } function g(r, e) { if (t.isBuffer(e)) { var n = 0 | d(e.length); return r = a(r, n), 0 === r.length ? r : (e.copy(r, 0, 0, n), r) } if (e) { if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || Z(e.length) ? a(r, 0) : l(r, e); if ("Buffer" === e.type && Q(e.data)) return l(r, e.data) } throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") } function d(t) { if (t >= o()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes"); return 0 | t } function y(r) { return +r != r && (r = 0), t.alloc(+r) } function v(r, e) { if (t.isBuffer(r)) return r.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(r) || r instanceof ArrayBuffer)) return r.byteLength; "string" != typeof r && (r = "" + r); var n = r.length; if (0 === n) return 0; for (var i = !1; ;) switch (e) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return z(r).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return J(r).length; default: if (i) return z(r).length; e = ("" + e).toLowerCase(), i = !0 } } function w(t, r, e) { var n = !1; if ((void 0 === r || r < 0) && (r = 0), r > this.length) return ""; if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return ""; if (e >>>= 0, r >>>= 0, e <= r) return ""; for (t || (t = "utf8") ; ;) switch (t) { case "hex": return M(this, r, e); case "utf8": case "utf-8": return U(this, r, e); case "ascii": return I(this, r, e); case "latin1": case "binary": return O(this, r, e); case "base64": return S(this, r, e); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return C(this, r, e); default: if (n) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), n = !0 } } function m(t, r, e) { var n = t[r]; t[r] = t[e], t[e] = n } function b(r, e, n, i, o) { if (0 === r.length) return -1; if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : r.length - 1), n < 0 && (n = r.length + n), n >= r.length) { if (o) return -1; n = r.length - 1 } else if (n < 0) { if (!o) return -1; n = 0 } if ("string" == typeof e && (e = t.from(e, i)), t.isBuffer(e)) return 0 === e.length ? -1 : E(r, e, n, i, o); if ("number" == typeof e) return e = 255 & e, t.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(r, e, n) : Uint8Array.prototype.lastIndexOf.call(r, e, n) : E(r, [e], n, i, o); throw new TypeError("val must be string, number or Buffer") } function E(t, r, e, n, i) { function o(t, r) { return 1 === a ? t[r] : t.readUInt16BE(r * a) } var a = 1, u = t.length, f = r.length; if (void 0 !== n && (n = String(n).toLowerCase(), "ucs2" === n || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) { if (t.length < 2 || r.length < 2) return -1; a = 2, u /= 2, f /= 2, e /= 2 } var s; if (i) { var h = -1; for (s = e; s < u; s++) if (o(t, s) === o(r, h === -1 ? 0 : s - h)) { if (h === -1 && (h = s), s - h + 1 === f) return h * a } else h !== -1 && (s -= s - h), h = -1 } else for (e + f > u && (e = u - f), s = e; s >= 0; s--) { for (var c = !0, l = 0; l < f; l++) if (o(t, s + l) !== o(r, l)) { c = !1; break } if (c) return s } return -1 } function A(t, r, e, n) { e = Number(e) || 0; var i = t.length - e; n ? (n = Number(n), n > i && (n = i)) : n = i; var o = r.length; if (o % 2 !== 0) throw new TypeError("Invalid hex string"); n > o / 2 && (n = o / 2); for (var a = 0; a < n; ++a) { var u = parseInt(r.substr(2 * a, 2), 16); if (isNaN(u)) return a; t[e + a] = u } return a } function _(t, r, e, n) { return W(z(r, t.length - e), t, e, n) } function R(t, r, e, n) { return W(G(r), t, e, n) } function x(t, r, e, n) { return R(t, r, e, n) } function T(t, r, e, n) { return W(J(r), t, e, n) } function B(t, r, e, n) { return W(V(r, t.length - e), t, e, n) } function S(t, r, e) { return 0 === r && e === t.length ? $.fromByteArray(t) : $.fromByteArray(t.slice(r, e)) } function U(t, r, e) { e = Math.min(t.length, e); for (var n = [], i = r; i < e;) { var o = t[i], a = null, u = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1; if (i + u <= e) { var f, s, h, c; switch (u) { case 1: o < 128 && (a = o); break; case 2: f = t[i + 1], 128 === (192 & f) && (c = (31 & o) << 6 | 63 & f, c > 127 && (a = c)); break; case 3: f = t[i + 1], s = t[i + 2], 128 === (192 & f) && 128 === (192 & s) && (c = (15 & o) << 12 | (63 & f) << 6 | 63 & s, c > 2047 && (c < 55296 || c > 57343) && (a = c)); break; case 4: f = t[i + 1], s = t[i + 2], h = t[i + 3], 128 === (192 & f) && 128 === (192 & s) && 128 === (192 & h) && (c = (15 & o) << 18 | (63 & f) << 12 | (63 & s) << 6 | 63 & h, c > 65535 && c < 1114112 && (a = c)) } } null === a ? (a = 65533, u = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += u } return P(n) } function P(t) { var r = t.length; if (r <= tt) return String.fromCharCode.apply(String, t); for (var e = "", n = 0; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += tt)); return e } function I(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]); return n } function O(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]); return n } function M(t, r, e) { var n = t.length; (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n); for (var i = "", o = r; o < e; ++o) i += q(t[o]); return i } function C(t, r, e) { for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]); return i } function L(t, r, e) { if (t % 1 !== 0 || t < 0) throw new RangeError("offset is not uint"); if (t + r > e) throw new RangeError("Trying to access beyond buffer length") } function Y(r, e, n, i, o, a) { if (!t.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > o || e < a) throw new RangeError('"value" argument is out of bounds'); if (n + i > r.length) throw new RangeError("Index out of range") } function k(t, r, e, n) { r < 0 && (r = 65535 + r + 1); for (var i = 0, o = Math.min(t.length - e, 2) ; i < o; ++i) t[e + i] = (r & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i) } function D(t, r, e, n) { r < 0 && (r = 4294967295 + r + 1); for (var i = 0, o = Math.min(t.length - e, 4) ; i < o; ++i) t[e + i] = r >>> 8 * (n ? i : 3 - i) & 255 } function j(t, r, e, n, i, o) { if (e + n > t.length) throw new RangeError("Index out of range"); if (e < 0) throw new RangeError("Index out of range") } function H(t, r, e, n, i) { return i || j(t, r, e, 4, 3.4028234663852886e38, -3.4028234663852886e38), K.write(t, r, e, n, 23, 4), e + 4 } function N(t, r, e, n, i) { return i || j(t, r, e, 8, 1.7976931348623157e308, -1.7976931348623157e308), K.write(t, r, e, n, 52, 8), e + 8 } function F(t) { if (t = X(t).replace(rt, ""), t.length < 2) return ""; for (; t.length % 4 !== 0;) t += "="; return t } function X(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") } function q(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function z(t, r) { r = r || 1 / 0; for (var e, n = t.length, i = null, o = [], a = 0; a < n; ++a) { if (e = t.charCodeAt(a), e > 55295 && e < 57344) { if (!i) { if (e > 56319) { (r -= 3) > -1 && o.push(239, 191, 189); continue } if (a + 1 === n) { (r -= 3) > -1 && o.push(239, 191, 189); continue } i = e; continue } if (e < 56320) { (r -= 3) > -1 && o.push(239, 191, 189), i = e; continue } e = (i - 55296 << 10 | e - 56320) + 65536 } else i && (r -= 3) > -1 && o.push(239, 191, 189); if (i = null, e < 128) { if ((r -= 1) < 0) break; o.push(e) } else if (e < 2048) { if ((r -= 2) < 0) break; o.push(e >> 6 | 192, 63 & e | 128) } else if (e < 65536) { if ((r -= 3) < 0) break; o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128) } else { if (!(e < 1114112)) throw new Error("Invalid code point"); if ((r -= 4) < 0) break; o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128) } } return o } function G(t) { for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e)); return r } function V(t, r) { for (var e, n, i, o = [], a = 0; a < t.length && !((r -= 2) < 0) ; ++a) e = t.charCodeAt(a), n = e >> 8, i = e % 256, o.push(i), o.push(n); return o } function J(t) { return $.toByteArray(F(t)) } function W(t, r, e, n) { for (var i = 0; i < n && !(i + e >= r.length || i >= t.length) ; ++i) r[i + e] = t[i]; return i } function Z(t) { return t !== t } var $ = e(11), K = e(4), Q = e(14); r.Buffer = t, r.SlowBuffer = y, r.INSPECT_MAX_BYTES = 50, t.TYPED_ARRAY_SUPPORT = void 0 !== n.TYPED_ARRAY_SUPPORT ? n.TYPED_ARRAY_SUPPORT : i(), r.kMaxLength = o(), t.poolSize = 8192, t._augment = function (r) { return r.__proto__ = t.prototype, r }, t.from = function (t, r, e) { return u(null, t, r, e) }, t.TYPED_ARRAY_SUPPORT && (t.prototype.__proto__ = Uint8Array.prototype, t.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && t[Symbol.species] === t && Object.defineProperty(t, Symbol.species, { value: null, configurable: !0 })), t.alloc = function (t, r, e) { return s(null, t, r, e) }, t.allocUnsafe = function (t) { return h(null, t) }, t.allocUnsafeSlow = function (t) { return h(null, t) }, t.isBuffer = function (t) { return !(null == t || !t._isBuffer) }, t.compare = function (r, e) { if (!t.isBuffer(r) || !t.isBuffer(e)) throw new TypeError("Arguments must be Buffers"); if (r === e) return 0; for (var n = r.length, i = e.length, o = 0, a = Math.min(n, i) ; o < a; ++o) if (r[o] !== e[o]) { n = r[o], i = e[o]; break } return n < i ? -1 : i < n ? 1 : 0 }, t.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, t.concat = function (r, e) { if (!Q(r)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === r.length) return t.alloc(0); var n; if (void 0 === e) for (e = 0, n = 0; n < r.length; ++n) e += r[n].length; var i = t.allocUnsafe(e), o = 0; for (n = 0; n < r.length; ++n) { var a = r[n]; if (!t.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers'); a.copy(i, o), o += a.length } return i }, t.byteLength = v, t.prototype._isBuffer = !0, t.prototype.swap16 = function () { var t = this.length; if (t % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var r = 0; r < t; r += 2) m(this, r, r + 1); return this }, t.prototype.swap32 = function () { var t = this.length; if (t % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var r = 0; r < t; r += 4) m(this, r, r + 3), m(this, r + 1, r + 2); return this }, t.prototype.swap64 = function () { var t = this.length; if (t % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var r = 0; r < t; r += 8) m(this, r, r + 7), m(this, r + 1, r + 6), m(this, r + 2, r + 5), m(this, r + 3, r + 4); return this }, t.prototype.toString = function () { var t = 0 | this.length; return 0 === t ? "" : 0 === arguments.length ? U(this, 0, t) : w.apply(this, arguments) }, t.prototype.equals = function (r) { if (!t.isBuffer(r)) throw new TypeError("Argument must be a Buffer"); return this === r || 0 === t.compare(this, r) }, t.prototype.inspect = function () { var t = "", e = r.INSPECT_MAX_BYTES; return this.length > 0 && (t = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (t += " ... ")), "<Buffer " + t + ">" }, t.prototype.compare = function (r, e, n, i, o) { if (!t.isBuffer(r)) throw new TypeError("Argument must be a Buffer"); if (void 0 === e && (e = 0), void 0 === n && (n = r ? r.length : 0), void 0 === i && (i = 0), void 0 === o && (o = this.length), e < 0 || n > r.length || i < 0 || o > this.length) throw new RangeError("out of range index"); if (i >= o && e >= n) return 0; if (i >= o) return -1; if (e >= n) return 1; if (e >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === r) return 0; for (var a = o - i, u = n - e, f = Math.min(a, u), s = this.slice(i, o), h = r.slice(e, n), c = 0; c < f; ++c) if (s[c] !== h[c]) { a = s[c], u = h[c]; break } return a < u ? -1 : u < a ? 1 : 0 }, t.prototype.includes = function (t, r, e) { return this.indexOf(t, r, e) !== -1 }, t.prototype.indexOf = function (t, r, e) { return b(this, t, r, e, !0) }, t.prototype.lastIndexOf = function (t, r, e) { return b(this, t, r, e, !1) }, t.prototype.write = function (t, r, e, n) { if (void 0 === r) n = "utf8", e = this.length, r = 0; else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0; else { if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); r = 0 | r, isFinite(e) ? (e = 0 | e, void 0 === n && (n = "utf8")) : (n = e, e = void 0) } var i = this.length - r; if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); for (var o = !1; ;) switch (n) { case "hex": return A(this, t, r, e); case "utf8": case "utf-8": return _(this, t, r, e); case "ascii": return R(this, t, r, e); case "latin1": case "binary": return x(this, t, r, e); case "base64": return T(this, t, r, e); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return B(this, t, r, e); default: if (o) throw new TypeError("Unknown encoding: " + n); n = ("" + n).toLowerCase(), o = !0 } }, t.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var tt = 4096; t.prototype.slice = function (r, e) { var n = this.length; r = ~~r, e = void 0 === e ? n : ~~e, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), e < r && (e = r); var i; if (t.TYPED_ARRAY_SUPPORT) i = this.subarray(r, e), i.__proto__ = t.prototype; else { var o = e - r; i = new t(o, (void 0)); for (var a = 0; a < o; ++a) i[a] = this[a + r] } return i }, t.prototype.readUIntLE = function (t, r, e) { t = 0 | t, r = 0 | r, e || L(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256) ;) n += this[t + o] * i; return n }, t.prototype.readUIntBE = function (t, r, e) { t = 0 | t, r = 0 | r, e || L(t, r, this.length); for (var n = this[t + --r], i = 1; r > 0 && (i *= 256) ;) n += this[t + --r] * i; return n }, t.prototype.readUInt8 = function (t, r) { return r || L(t, 1, this.length), this[t] }, t.prototype.readUInt16LE = function (t, r) { return r || L(t, 2, this.length), this[t] | this[t + 1] << 8 }, t.prototype.readUInt16BE = function (t, r) { return r || L(t, 2, this.length), this[t] << 8 | this[t + 1] }, t.prototype.readUInt32LE = function (t, r) { return r || L(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, t.prototype.readUInt32BE = function (t, r) { return r || L(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, t.prototype.readIntLE = function (t, r, e) { t = 0 | t, r = 0 | r, e || L(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256) ;) n += this[t + o] * i; return i *= 128, n >= i && (n -= Math.pow(2, 8 * r)), n }, t.prototype.readIntBE = function (t, r, e) { t = 0 | t, r = 0 | r, e || L(t, r, this.length); for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256) ;) o += this[t + --n] * i; return i *= 128, o >= i && (o -= Math.pow(2, 8 * r)), o }, t.prototype.readInt8 = function (t, r) { return r || L(t, 1, this.length), 128 & this[t] ? (255 - this[t] + 1) * -1 : this[t] }, t.prototype.readInt16LE = function (t, r) { r || L(t, 2, this.length); var e = this[t] | this[t + 1] << 8; return 32768 & e ? 4294901760 | e : e }, t.prototype.readInt16BE = function (t, r) { r || L(t, 2, this.length); var e = this[t + 1] | this[t] << 8; return 32768 & e ? 4294901760 | e : e }, t.prototype.readInt32LE = function (t, r) { return r || L(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, t.prototype.readInt32BE = function (t, r) { return r || L(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, t.prototype.readFloatLE = function (t, r) { return r || L(t, 4, this.length), K.read(this, t, !0, 23, 4) }, t.prototype.readFloatBE = function (t, r) { return r || L(t, 4, this.length), K.read(this, t, !1, 23, 4) }, t.prototype.readDoubleLE = function (t, r) { return r || L(t, 8, this.length), K.read(this, t, !0, 52, 8) }, t.prototype.readDoubleBE = function (t, r) { return r || L(t, 8, this.length), K.read(this, t, !1, 52, 8) }, t.prototype.writeUIntLE = function (t, r, e, n) { if (t = +t, r = 0 | r, e = 0 | e, !n) { var i = Math.pow(2, 8 * e) - 1; Y(this, t, r, e, i, 0) } var o = 1, a = 0; for (this[r] = 255 & t; ++a < e && (o *= 256) ;) this[r + a] = t / o & 255; return r + e }, t.prototype.writeUIntBE = function (t, r, e, n) { if (t = +t, r = 0 | r, e = 0 | e, !n) { var i = Math.pow(2, 8 * e) - 1; Y(this, t, r, e, i, 0) } var o = e - 1, a = 1; for (this[r + o] = 255 & t; --o >= 0 && (a *= 256) ;) this[r + o] = t / a & 255; return r + e }, t.prototype.writeUInt8 = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 1, 255, 0), t.TYPED_ARRAY_SUPPORT || (r = Math.floor(r)), this[e] = 255 & r, e + 1 }, t.prototype.writeUInt16LE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 2, 65535, 0), t.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & r, this[e + 1] = r >>> 8) : k(this, r, e, !0), e + 2 }, t.prototype.writeUInt16BE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 2, 65535, 0), t.TYPED_ARRAY_SUPPORT ? (this[e] = r >>> 8, this[e + 1] = 255 & r) : k(this, r, e, !1), e + 2 }, t.prototype.writeUInt32LE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 4, 4294967295, 0), t.TYPED_ARRAY_SUPPORT ? (this[e + 3] = r >>> 24, this[e + 2] = r >>> 16, this[e + 1] = r >>> 8, this[e] = 255 & r) : D(this, r, e, !0), e + 4 }, t.prototype.writeUInt32BE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 4, 4294967295, 0), t.TYPED_ARRAY_SUPPORT ? (this[e] = r >>> 24, this[e + 1] = r >>> 16, this[e + 2] = r >>> 8, this[e + 3] = 255 & r) : D(this, r, e, !1), e + 4 }, t.prototype.writeIntLE = function (t, r, e, n) { if (t = +t, r = 0 | r, !n) { var i = Math.pow(2, 8 * e - 1); Y(this, t, r, e, i - 1, -i) } var o = 0, a = 1, u = 0; for (this[r] = 255 & t; ++o < e && (a *= 256) ;) t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / a >> 0) - u & 255; return r + e }, t.prototype.writeIntBE = function (t, r, e, n) { if (t = +t, r = 0 | r, !n) { var i = Math.pow(2, 8 * e - 1); Y(this, t, r, e, i - 1, -i) } var o = e - 1, a = 1, u = 0; for (this[r + o] = 255 & t; --o >= 0 && (a *= 256) ;) t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / a >> 0) - u & 255; return r + e }, t.prototype.writeInt8 = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 1, 127, -128), t.TYPED_ARRAY_SUPPORT || (r = Math.floor(r)), r < 0 && (r = 255 + r + 1), this[e] = 255 & r, e + 1 }, t.prototype.writeInt16LE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 2, 32767, -32768), t.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & r, this[e + 1] = r >>> 8) : k(this, r, e, !0), e + 2 }, t.prototype.writeInt16BE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 2, 32767, -32768), t.TYPED_ARRAY_SUPPORT ? (this[e] = r >>> 8, this[e + 1] = 255 & r) : k(this, r, e, !1), e + 2 }, t.prototype.writeInt32LE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 4, 2147483647, -2147483648), t.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & r, this[e + 1] = r >>> 8, this[e + 2] = r >>> 16, this[e + 3] = r >>> 24) : D(this, r, e, !0), e + 4 }, t.prototype.writeInt32BE = function (r, e, n) { return r = +r, e = 0 | e, n || Y(this, r, e, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), t.TYPED_ARRAY_SUPPORT ? (this[e] = r >>> 24, this[e + 1] = r >>> 16, this[e + 2] = r >>> 8, this[e + 3] = 255 & r) : D(this, r, e, !1), e + 4 }, t.prototype.writeFloatLE = function (t, r, e) { return H(this, t, r, !0, e) }, t.prototype.writeFloatBE = function (t, r, e) { return H(this, t, r, !1, e) }, t.prototype.writeDoubleLE = function (t, r, e) { return N(this, t, r, !0, e) }, t.prototype.writeDoubleBE = function (t, r, e) { return N(this, t, r, !1, e) }, t.prototype.copy = function (r, e, n, i) { if (n || (n = 0), i || 0 === i || (i = this.length), e >= r.length && (e = r.length), e || (e = 0), i > 0 && i < n && (i = n), i === n) return 0; if (0 === r.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (i < 0) throw new RangeError("sourceEnd out of bounds"); i > this.length && (i = this.length), r.length - e < i - n && (i = r.length - e + n); var o, a = i - n; if (this === r && n < e && e < i) for (o = a - 1; o >= 0; --o) r[o + e] = this[o + n]; else if (a < 1e3 || !t.TYPED_ARRAY_SUPPORT) for (o = 0; o < a; ++o) r[o + e] = this[o + n]; else Uint8Array.prototype.set.call(r, this.subarray(n, n + a), e); return a }, t.prototype.fill = function (r, e, n, i) { if ("string" == typeof r) { if ("string" == typeof e ? (i = e, e = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), 1 === r.length) { var o = r.charCodeAt(0); o < 256 && (r = o) } if (void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string"); if ("string" == typeof i && !t.isEncoding(i)) throw new TypeError("Unknown encoding: " + i) } else "number" == typeof r && (r = 255 & r); if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index"); if (n <= e) return this; e >>>= 0, n = void 0 === n ? this.length : n >>> 0, r || (r = 0); var a; if ("number" == typeof r) for (a = e; a < n; ++a) this[a] = r; else { var u = t.isBuffer(r) ? r : z(new t(r, i).toString()), f = u.length; for (a = 0; a < n - e; ++a) this[a + e] = u[a % f] } return this }; var rt = /[^+\/0-9A-Za-z-_]/g
    }).call(r, e(1).Buffer, function () { return this }())
}, function (t, r) { var e = {}.toString; t.exports = Array.isArray || function (t) { return "[object Array]" == e.call(t) } }, function (t, r, e) { function n(t, r, e) { if (!t) throw new TypeError("must specify data as first parameter"); if (e = 0 | +(e || 0), Array.isArray(t) && Array.isArray(t[0])) { var n = t[0].length, o = t.length * n; r && "string" != typeof r || (r = new (i(r || "float32"))(o + e)); var a = r.length - e; if (o !== a) throw new Error("source length " + o + " (" + n + "x" + t.length + ") does not match destination length " + a); for (var u = 0, f = e; u < t.length; u++) for (var s = 0; s < n; s++) r[f++] = t[u][s] } else if (r && "string" != typeof r) r.set(t, e); else { var h = i(r || "float32"); 0 === e ? r = new h(t) : (r = new h(t.length + e), r.set(t, e)) } return r } var i = e(3); t.exports = n }, function (t, r, e) { function n(t, r, e) { if (!u(r)) throw new TypeError("iterator must be a function"); arguments.length < 3 && (e = this), "[object Array]" === f.call(t) ? i(t, r, e) : "string" == typeof t ? o(t, r, e) : a(t, r, e) } function i(t, r, e) { for (var n = 0, i = t.length; n < i; n++) s.call(t, n) && r.call(e, t[n], n, t) } function o(t, r, e) { for (var n = 0, i = t.length; n < i; n++) r.call(e, t.charAt(n), n, t) } function a(t, r, e) { for (var n in t) s.call(t, n) && r.call(e, t[n], n, t) } var u = e(5); t.exports = n; var f = Object.prototype.toString, s = Object.prototype.hasOwnProperty }, function (t, r) { (function (r) { "undefined" != typeof window ? t.exports = window : "undefined" != typeof r ? t.exports = r : "undefined" != typeof self ? t.exports = self : t.exports = {} }).call(r, function () { return this }()) }, function (t, r) { t.exports = function (t) { if (!t || "string" != typeof t) throw new Error("must specify property for indexof search"); return new Function("array", "value", "start", ["start = start || 0", "for (var i=start; i<array.length; i++)", '  if (array[i]["' + t + '"] === value)', "      return i", "return -1"].join("\n")) } }, function (t, r) { "function" == typeof Object.create ? t.exports = function (t, r) { t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }) } : t.exports = function (t, r) { t.super_ = r; var e = function () { }; e.prototype = r.prototype, t.prototype = new e, t.prototype.constructor = t } }, function (t, r) { t.exports = function (t) { return !(null == t || !(t._isBuffer || t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t))) } }, function (t, r, e) { function n(t) { this.glyphs = [], this._measure = this.computeMetrics.bind(this), this.update(t) } function i(t) { Object.defineProperty(n.prototype, t, { get: o(t), configurable: !0 }) } function o(t) { return new Function(["return function " + t + "() {", "  return this._" + t, "}"].join("\n"))() } function a(t, r) { if (!t.chars || 0 === t.chars.length) return null; var e = g(t.chars, r); return e >= 0 ? t.chars[e] : null } function u(t) { for (var r = 0; r < y.length; r++) { var e = y[r].charCodeAt(0), n = g(t.chars, e); if (n >= 0) return t.chars[n].height } return 0 } function f(t) { for (var r = 0; r < v.length; r++) { var e = v[r].charCodeAt(0), n = g(t.chars, e); if (n >= 0) return t.chars[n] } return 0 } function s(t) { for (var r = 0; r < w.length; r++) { var e = w[r].charCodeAt(0), n = g(t.chars, e); if (n >= 0) return t.chars[n].height } return 0 } function h(t, r, e) { if (!t.kernings || 0 === t.kernings.length) return 0; for (var n = t.kernings, i = 0; i < n.length; i++) { var o = n[i]; if (o.first === r && o.second === e) return o.amount } return 0 } function c(t) { return "center" === t ? A : "right" === t ? _ : E } var l = e(38), p = e(2), g = e(18)("id"), d = e(10), y = ["x", "e", "a", "o", "n", "s", "r", "c", "u", "m", "v", "w", "z"], v = ["m", "w"], w = ["H", "I", "N", "E", "F", "K", "L", "T", "U", "V", "W", "X", "Y", "Z"], m = "\t".charCodeAt(0), b = " ".charCodeAt(0), E = 0, A = 1, _ = 2; t.exports = function (t) { return new n(t) }, n.prototype.update = function (t) { if (t = p({ measure: this._measure }, t), this._opt = t, this._opt.tabSize = d(this._opt.tabSize, 4), !t.font) throw new Error("must provide a valid bitmap font"); var r = this.glyphs, e = t.text || "", n = t.font; this._setupSpaceGlyphs(n); var i = l.lines(e, t), o = t.width || 0; r.length = 0; var a = i.reduce(function (t, r) { return Math.max(t, r.width, o) }, 0), f = 0, g = 0, y = d(t.lineHeight, n.common.lineHeight), v = n.common.base, w = y - v, m = t.letterSpacing || 0, b = y * i.length - w, E = c(this._opt.align); g -= b, this._width = a, this._height = b, this._descender = y - v, this._baseline = v, this._xHeight = u(n), this._capHeight = s(n), this._lineHeight = y, this._ascender = y - w - this._xHeight; var R = this; i.forEach(function (t, i) { for (var o, u = t.start, s = t.end, c = t.width, l = u; l < s; l++) { var p = e.charCodeAt(l), d = R.getGlyph(n, p); if (d) { o && (f += h(n, o.id, d.id)); var v = f; E === A ? v += (a - c) / 2 : E === _ && (v += a - c), r.push({ position: [v, g], data: d, index: l, line: i }), f += d.xadvance + m, o = d } } g += y, f = 0 }), this._linesTotal = i.length }, n.prototype._setupSpaceGlyphs = function (t) { if (this._fallbackSpaceGlyph = null, this._fallbackTabGlyph = null, t.chars && 0 !== t.chars.length) { var r = a(t, b) || f(t) || t.chars[0], e = this._opt.tabSize * r.xadvance; this._fallbackSpaceGlyph = r, this._fallbackTabGlyph = p(r, { x: 0, y: 0, xadvance: e, id: m, xoffset: 0, yoffset: 0, width: 0, height: 0 }) } }, n.prototype.getGlyph = function (t, r) { var e = a(t, r); return e ? e : r === m ? this._fallbackTabGlyph : r === b ? this._fallbackSpaceGlyph : null }, n.prototype.computeMetrics = function (t, r, e, n) { var i, o, a = this._opt.letterSpacing || 0, u = this._opt.font, f = 0, s = 0, c = 0; if (!u.chars || 0 === u.chars.length) return { start: r, end: r, width: 0 }; e = Math.min(t.length, e); for (var l = r; l < e; l++) { var p = t.charCodeAt(l), i = this.getGlyph(u, p); if (i) { var g = (i.xoffset, o ? h(u, o.id, i.id) : 0); f += g; var d = f + i.xadvance + a, y = f + i.width; if (y >= n || d >= n) break; f = d, s = y, o = i } c++ } return o && (s += o.xoffset), { start: r, end: r + c, width: s } }, ["width", "height", "descender", "ascender", "xHeight", "baseline", "capHeight", "lineHeight"].forEach(i) }, function (t, r, e) { (function (r) { function n(t) { var r = Object.prototype.toString; return "[object ArrayBuffer]" === r.call(t) } function i(t) { if (l) return c(t, { responseType: "arraybuffer" }); if ("undefined" == typeof window.XMLHttpRequest) throw new Error("your browser does not support XHR loading"); var r = new window.XMLHttpRequest; return r.overrideMimeType("text/plain; charset=x-user-defined"), c({ xhr: r }, t) } var o = e(39), a = function () { }, u = e(27), f = e(29), s = e(28), h = e(23), c = e(2), l = function () { return window.XMLHttpRequest && "withCredentials" in new XMLHttpRequest }(); t.exports = function (t, e) { e = "function" == typeof e ? e : a, "string" == typeof t ? t = { uri: t } : t || (t = {}); var c = t.binary; c && (t = i(t)), o(t, function (i, o, c) { if (i) return e(i); if (!/^2/.test(o.statusCode)) return e(new Error("http status code: " + o.statusCode)); if (!c) return e(new Error("no body result")); var l = !1; if (n(c)) { var p = new Uint8Array(c); c = new r(p, "binary") } h(c) && (l = !0, "string" == typeof c && (c = new r(c, "binary"))), l || (r.isBuffer(c) && (c = c.toString(t.encoding)), c = c.trim()); var g; try { var d = o.headers["content-type"]; g = l ? s(c) : /json/.test(d) || "{" === c.charAt(0) ? JSON.parse(c) : /xml/.test(d) || "<" === c.charAt(0) ? f(c) : u(c) } catch (y) { e(new Error("error parsing font " + y.message)), e = a } e(null, g) }) } }).call(r, e(1).Buffer) }, function (t, r, e) { (function (r) { var n = e(12), i = new r([66, 77, 70, 3]); t.exports = function (t) { return "string" == typeof t ? "BMF" === t.substring(0, 3) : t.length > 4 && n(t.slice(0, 4), i) } }).call(r, e(1).Buffer) }, function (t, r) { "use strict"; function e() { for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0, e = t.length; r < e; ++r) u[r] = t[r], f[t.charCodeAt(r)] = r; f["-".charCodeAt(0)] = 62, f["_".charCodeAt(0)] = 63 } function n(t) { var r, e, n, i, o, a, u = t.length; if (u % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); o = "=" === t[u - 2] ? 2 : "=" === t[u - 1] ? 1 : 0, a = new s(3 * u / 4 - o), n = o > 0 ? u - 4 : u; var h = 0; for (r = 0, e = 0; r < n; r += 4, e += 3) i = f[t.charCodeAt(r)] << 18 | f[t.charCodeAt(r + 1)] << 12 | f[t.charCodeAt(r + 2)] << 6 | f[t.charCodeAt(r + 3)], a[h++] = i >> 16 & 255, a[h++] = i >> 8 & 255, a[h++] = 255 & i; return 2 === o ? (i = f[t.charCodeAt(r)] << 2 | f[t.charCodeAt(r + 1)] >> 4, a[h++] = 255 & i) : 1 === o && (i = f[t.charCodeAt(r)] << 10 | f[t.charCodeAt(r + 1)] << 4 | f[t.charCodeAt(r + 2)] >> 2, a[h++] = i >> 8 & 255, a[h++] = 255 & i), a } function i(t) { return u[t >> 18 & 63] + u[t >> 12 & 63] + u[t >> 6 & 63] + u[63 & t] } function o(t, r, e) { for (var n, o = [], a = r; a < e; a += 3) n = (t[a] << 16) + (t[a + 1] << 8) + t[a + 2], o.push(i(n)); return o.join("") } function a(t) { for (var r, e = t.length, n = e % 3, i = "", a = [], f = 16383, s = 0, h = e - n; s < h; s += f) a.push(o(t, s, s + f > h ? h : s + f)); return 1 === n ? (r = t[e - 1], i += u[r >> 2], i += u[r << 4 & 63], i += "==") : 2 === n && (r = (t[e - 2] << 8) + t[e - 1], i += u[r >> 10], i += u[r >> 4 & 63], i += u[r << 2 & 63], i += "="), a.push(i), a.join("") } r.toByteArray = n, r.fromByteArray = a; var u = [], f = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array; e() }, function (t, r) { var e = {}.toString; t.exports = Array.isArray || function (t) { return "[object Array]" == e.call(t) } }, function (t, r) { function e(t) { var r = !1; return function () { if (!r) return r = !0, t.apply(this, arguments) } } t.exports = e, e.proto = e(function () { Object.defineProperty(Function.prototype, "once", { value: function () { return e(this) }, configurable: !0 }) }) }, function (t, r) { function e(t, r) { if (t = t.replace(/\t+/g, " ").trim(), !t) return null; var e = t.indexOf(" "); if (e === -1) throw new Error("no named row at line " + r); var i = t.substring(0, e); t = t.substring(e + 1), t = t.replace(/letter=[\'\"]\S+[\'\"]/gi, ""), t = t.split("="), t = t.map(function (t) { return t.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g) }); for (var o = [], a = 0; a < t.length; a++) { var u = t[a]; 0 === a ? o.push({ key: u[0], data: "" }) : a === t.length - 1 ? o[o.length - 1].data = n(u[0]) : (o[o.length - 1].data = n(u[0]), o.push({ key: u[1], data: "" })) } var f = { key: i, data: {} }; return o.forEach(function (t) { f.data[t.key] = t.data }), f } function n(t) { return t && 0 !== t.length ? 0 === t.indexOf('"') || 0 === t.indexOf("'") ? t.substring(1, t.length - 1) : t.indexOf(",") !== -1 ? i(t) : parseInt(t, 10) : "" } function i(t) { return t.split(",").map(function (t) { return parseInt(t, 10) }) } t.exports = function (t) { if (!t) throw new Error("no data provided"); t = t.toString().trim(); var r = { pages: [], chars: [], kernings: [] }, n = t.split(/\r\n?|\n/g); if (0 === n.length) throw new Error("no data in BMFont file"); for (var i = 0; i < n.length; i++) { var o = e(n[i], i); if (o) if ("page" === o.key) { if ("number" != typeof o.data.id) throw new Error("malformed file at line " + i + " -- needs page id=N"); if ("string" != typeof o.data.file) throw new Error("malformed file at line " + i + ' -- needs page file="path"'); r.pages[o.data.id] = o.data.file } else "chars" === o.key || "kernings" === o.key || ("char" === o.key ? r.chars.push(o.data) : "kerning" === o.key ? r.kernings.push(o.data) : r[o.key] = o.data) } return r } }, function (t, r) { function e(t, r, e) { if (e > r.length - 1) return 0; var f = r.readUInt8(e++), s = r.readInt32LE(e); switch (e += 4, f) { case 1: t.info = n(r, e); break; case 2: t.common = i(r, e); break; case 3: t.pages = o(r, e, s); break; case 4: t.chars = a(r, e, s); break; case 5: t.kernings = u(r, e, s) } return 5 + s } function n(t, r) { var e = {}; e.size = t.readInt16LE(r); var n = t.readUInt8(r + 2); return e.smooth = n >> 7 & 1, e.unicode = n >> 6 & 1, e.italic = n >> 5 & 1, e.bold = n >> 4 & 1, n >> 3 & 1 && (e.fixedHeight = 1), e.charset = t.readUInt8(r + 3) || "", e.stretchH = t.readUInt16LE(r + 4), e.aa = t.readUInt8(r + 6), e.padding = [t.readInt8(r + 7), t.readInt8(r + 8), t.readInt8(r + 9), t.readInt8(r + 10)], e.spacing = [t.readInt8(r + 11), t.readInt8(r + 12)], e.outline = t.readUInt8(r + 13), e.face = s(t, r + 14), e } function i(t, r) { var e = {}; e.lineHeight = t.readUInt16LE(r), e.base = t.readUInt16LE(r + 2), e.scaleW = t.readUInt16LE(r + 4), e.scaleH = t.readUInt16LE(r + 6), e.pages = t.readUInt16LE(r + 8); t.readUInt8(r + 10); return e.packed = 0, e.alphaChnl = t.readUInt8(r + 11), e.redChnl = t.readUInt8(r + 12), e.greenChnl = t.readUInt8(r + 13), e.blueChnl = t.readUInt8(r + 14), e } function o(t, r, e) { for (var n = [], i = f(t, r), o = i.length + 1, a = e / o, u = 0; u < a; u++) n[u] = t.slice(r, r + i.length).toString("utf8"), r += o; return n } function a(t, r, e) { for (var n = [], i = e / 20, o = 0; o < i; o++) { var a = {}, u = 20 * o; a.id = t.readUInt32LE(r + 0 + u), a.x = t.readUInt16LE(r + 4 + u), a.y = t.readUInt16LE(r + 6 + u), a.width = t.readUInt16LE(r + 8 + u), a.height = t.readUInt16LE(r + 10 + u), a.xoffset = t.readInt16LE(r + 12 + u), a.yoffset = t.readInt16LE(r + 14 + u), a.xadvance = t.readInt16LE(r + 16 + u), a.page = t.readUInt8(r + 18 + u), a.chnl = t.readUInt8(r + 19 + u), n[o] = a } return n } function u(t, r, e) { for (var n = [], i = e / 10, o = 0; o < i; o++) { var a = {}, u = 10 * o; a.first = t.readUInt32LE(r + 0 + u), a.second = t.readUInt32LE(r + 4 + u), a.amount = t.readInt16LE(r + 8 + u), n[o] = a } return n } function f(t, r) { for (var e = r; e < t.length && 0 !== t[e]; e++); return t.slice(r, e) } function s(t, r) { return f(t, r).toString("utf8") } var h = [66, 77, 70]; t.exports = function (t) { if (t.length < 6) throw new Error("invalid buffer length for BMFont"); var r = h.every(function (r, e) { return t.readUInt8(e) === r }); if (!r) throw new Error("BMFont missing BMF byte header"); var n = 3, i = t.readUInt8(n++); if (i > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)"); for (var o = { kernings: [], chars: [] }, a = 0; a < 5; a++) n += e(o, t, n); return o } }, function (t, r, e) {
    function n(t) {
        var r = i(t);
        return r.reduce(function (t, r) { var e = o(r.nodeName); return t[e] = r.nodeValue, t }, {})
    } function i(t) { for (var r = [], e = 0; e < t.attributes.length; e++) r.push(t.attributes[e]); return r } function o(t) { return f[t.toLowerCase()] || t } var a = e(30), u = e(40), f = { scaleh: "scaleH", scalew: "scaleW", stretchh: "stretchH", lineheight: "lineHeight", alphachnl: "alphaChnl", redchnl: "redChnl", greenchnl: "greenChnl", bluechnl: "blueChnl" }; t.exports = function (t) { t = t.toString(); var r = u(t), e = { pages: [], chars: [], kernings: [] };["info", "common"].forEach(function (t) { var i = r.getElementsByTagName(t)[0]; i && (e[t] = a(n(i))) }); var i = r.getElementsByTagName("pages")[0]; if (!i) throw new Error("malformed file -- no <pages> element"); for (var o = i.getElementsByTagName("page"), f = 0; f < o.length; f++) { var s = o[f], h = parseInt(s.getAttribute("id"), 10), c = s.getAttribute("file"); if (isNaN(h)) throw new Error('malformed file -- page "id" attribute is NaN'); if (!c) throw new Error('malformed file -- needs page "file" attribute'); e.pages[parseInt(h, 10)] = c } return ["chars", "kernings"].forEach(function (t) { var i = r.getElementsByTagName(t)[0]; if (i) for (var o = t.substring(0, t.length - 1), u = i.getElementsByTagName(o), f = 0; f < u.length; f++) { var s = u[f]; e[t].push(a(n(s))) } }), e }
}, function (t, r) { function e(t) { return t.split(",").map(function (t) { return parseInt(t, 10) }) } var n = "chasrset"; t.exports = function (t) { n in t && (t.charset = t[n], delete t[n]); for (var r in t) "face" !== r && "charset" !== r && ("padding" === r || "spacing" === r ? t[r] = e(t[r]) : t[r] = parseInt(t[r], 10)); return t } }, function (t, r, e) { var n = e(37), i = e(16), o = function (t) { return "[object Array]" === Object.prototype.toString.call(t) }; t.exports = function (t) { if (!t) return {}; var r = {}; return i(n(t).split("\n"), function (t) { var e = t.indexOf(":"), i = n(t.slice(0, e)).toLowerCase(), a = n(t.slice(e + 1)); "undefined" == typeof r[i] ? r[i] = a : o(r[i]) ? r[i].push(a) : r[i] = [r[i], a] }), r } }, function (t, r, e) { var n = e(3), i = e(9), o = e(20), a = [0, 2, 3], u = [2, 1, 3]; t.exports = function (t, r) { t && (i(t) || o(t)) || (r = t || {}, t = null), r = "number" == typeof r ? { count: r } : r || {}; for (var e = "string" == typeof r.type ? r.type : "uint16", f = "number" == typeof r.count ? r.count : 1, s = r.start || 0, h = r.clockwise !== !1 ? a : u, c = h[0], l = h[1], p = h[2], g = 6 * f, d = t || new (n(e))(g), y = 0, v = 0; y < g; y += 6, v += 4) { var w = y + s; d[w + 0] = v + 0, d[w + 1] = v + 1, d[w + 2] = v + 2, d[w + 3] = v + c, d[w + 4] = v + l, d[w + 5] = v + p } return d } }, function (t, r, e) { function n(t) { c.call(this), "string" == typeof t && (t = { text: t }), this._opt = f({}, t), t && this.update(t) } var i = e(21), o = e(19), a = e(32), u = e(36), f = e(6), s = e(35), h = e(34), c = THREE.BufferGeometry; t.exports = function (t) { return new n(t) }, o(n, c), n.prototype.update = function (t) { if ("string" == typeof t && (t = { text: t }), t = f({}, this._opt, t), !t.font) throw new TypeError("must specify a { font } in options"); this.layout = i(t); var r = t.flipY !== !1, e = t.font, n = e.common.scaleW, o = e.common.scaleH, h = this.layout.glyphs.filter(function (t) { var r = t.data; return r.width * r.height > 0 }); this.visibleGlyphs = h; var c = s.positions(h), l = s.uvs(h, n, o, r), p = a({ clockwise: !0, type: "uint16", count: h.length }); if (u.index(this, p, 1, "uint16"), u.attr(this, "position", c, 2), u.attr(this, "uv", l, 2), !t.multipage && "page" in this.attributes) this.removeAttribute("page"); else if (t.multipage) { var g = s.pages(h); u.attr(this, "page", g, 1) } }, n.prototype.computeBoundingSphere = function () { null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere); var t = this.attributes.position.array, r = this.attributes.position.itemSize; return !t || !r || t.length < 2 ? (this.boundingSphere.radius = 0, void this.boundingSphere.center.set(0, 0, 0)) : (h.computeSphere(t, this.boundingSphere), void (isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.'))) }, n.prototype.computeBoundingBox = function () { null === this.boundingBox && (this.boundingBox = new THREE.Box3); var t = this.boundingBox, r = this.attributes.position.array, e = this.attributes.position.itemSize; return !r || !e || r.length < 2 ? void t.makeEmpty() : void h.computeBox(r, t) } }, function (t, r) { function e(t) { var r = t.length / n; i.min[0] = t[0], i.min[1] = t[1], i.max[0] = t[0], i.max[1] = t[1]; for (var e = 0; e < r; e++) { var o = t[e * n + 0], a = t[e * n + 1]; i.min[0] = Math.min(o, i.min[0]), i.min[1] = Math.min(a, i.min[1]), i.max[0] = Math.max(o, i.max[0]), i.max[1] = Math.max(a, i.max[1]) } } var n = 2, i = { min: [0, 0], max: [0, 0] }; t.exports.computeBox = function (t, r) { e(t), r.min.set(i.min[0], i.min[1], 0), r.max.set(i.max[0], i.max[1], 0) }, t.exports.computeSphere = function (t, r) { e(t); var n = i.min[0], o = i.min[1], a = i.max[0], u = i.max[1], f = a - n, s = u - o, h = Math.sqrt(f * f + s * s); r.center.set(n + f / 2, o + s / 2, 0), r.radius = h / 2 } }, function (t, r) { t.exports.pages = function e(t) { var e = new Float32Array(4 * t.length * 1), r = 0; return t.forEach(function (t) { var n = t.data.page || 0; e[r++] = n, e[r++] = n, e[r++] = n, e[r++] = n }), e }, t.exports.uvs = function n(t, r, e, i) { var n = new Float32Array(4 * t.length * 2), o = 0; return t.forEach(function (t) { var a = t.data, u = a.x + a.width, f = a.y + a.height, s = a.x / r, h = a.y / e, c = u / r, l = f / e; i && (h = (e - a.y) / e, l = (e - f) / e), n[o++] = s, n[o++] = h, n[o++] = s, n[o++] = l, n[o++] = c, n[o++] = l, n[o++] = c, n[o++] = h }), n }, t.exports.positions = function i(t) { var i = new Float32Array(4 * t.length * 2), r = 0; return t.forEach(function (t) { var e = t.data, n = t.position[0] + e.xoffset, o = t.position[1] + e.yoffset, a = e.width, u = e.height; i[r++] = n, i[r++] = o, i[r++] = n, i[r++] = o + u, i[r++] = n + a, i[r++] = o + u, i[r++] = n + a, i[r++] = o }), i } }, function (t, r, e) { function n(t, r, e, n) { "number" != typeof e && (e = 1), "string" != typeof n && (n = "uint16"); var i = !t.index && "function" != typeof t.setIndex, a = i ? t.getAttribute("index") : t.index, u = o(a, r, e, n); u && (i ? t.addAttribute("index", u) : t.index = u) } function i(t, r, e, n, i) { if ("number" != typeof n && (n = 3), "string" != typeof i && (i = "float32"), Array.isArray(e) && Array.isArray(e[0]) && e[0].length !== n) throw new Error("Nested vertex array has unexpected size; expected " + n + " but found " + e[0].length); var a = t.getAttribute(r), u = o(a, e, n, i); u && t.addAttribute(r, u) } function o(t, r, e, n) { return r = r || [], !t || a(t, r, e) ? (r = u(r, n), t = new THREE.BufferAttribute(r, e), t.needsUpdate = !0, t) : (u(r, t.array), t.needsUpdate = !0, null) } function a(t, r, e) { if (t.itemSize !== e) return !0; if (!t.array) return !0; var n = t.array.length; return Array.isArray(r) && Array.isArray(r[0]) ? n !== r.length * e : n !== r.length } var u = e(15); t.exports.attr = i, t.exports.index = n }, function (t, r) { function e(t) { return t.replace(/^\s*|\s*$/g, "") } r = t.exports = e, r.left = function (t) { return t.replace(/^\s*/, "") }, r.right = function (t) { return t.replace(/\s*$/, "") } }, function (t, r) { function e(t, r, e, n) { var i = t.indexOf(r, e); return i === -1 || i > n ? n : i } function n(t) { return s.test(t) } function i(t, r, e, n, i) { for (var o = [], a = e, f = e; f < n && f < r.length; f++) { var s = r.charAt(f), h = u.test(s); if (h || f === n - 1) { var c = h ? f : f + 1, l = t(r, a, c, i); o.push(l), a = f + 1 } } return o } function o(t, r, i, o, a, u) { var s = [], h = a; for ("nowrap" === u && (h = Number.MAX_VALUE) ; i < o && i < r.length;) { for (var c = e(r, f, i, o) ; i < c && n(r.charAt(i)) ;) i++; var l = t(r, i, c, h), p = i + (l.end - l.start), g = p + f.length; if (p < c) { for (; p > i && !n(r.charAt(p)) ;) p--; if (p === i) g > i + f.length && g--, p = g; else for (g = p; p > i && n(r.charAt(p - f.length)) ;) p-- } if (p >= i) { var d = t(r, i, p, h); s.push(d) } i = g } return s } function a(t, r, e, n) { var i = Math.min(n, e - r); return { start: r, end: r + i } } var u = /\n/, f = "\n", s = /\s/; t.exports = function (r, e) { var n = t.exports.lines(r, e); return n.map(function (t) { return r.substring(t.start, t.end) }).join("\n") }, t.exports.lines = function (t, r) { if (r = r || {}, 0 === r.width && "nowrap" !== r.mode) return []; t = t || ""; var e = "number" == typeof r.width ? r.width : Number.MAX_VALUE, n = Math.max(0, r.start || 0), u = "number" == typeof r.end ? r.end : t.length, f = r.mode, s = r.measure || a; return "pre" === f ? i(s, t, n, u, e) : o(s, t, n, u, e, f) } }, function (t, r, e) { "use strict"; function n(t, r) { for (var e = 0; e < t.length; e++) r(t[e]) } function i(t) { for (var r in t) if (t.hasOwnProperty(r)) return !1; return !0 } function o(t, r, e) { var n = t; return c(r) ? (e = r, "string" == typeof t && (n = { uri: t })) : n = p(r, { uri: t }), n.callback = e, n } function a(t, r, e) { return r = o(t, r, e), u(r) } function u(t) { function r() { 4 === s.readyState && o() } function e() { var t = void 0; if (s.response ? t = s.response : "text" !== s.responseType && s.responseType || (t = s.responseText || s.responseXML), b) try { t = JSON.parse(t) } catch (r) { } return t } function n(t) { clearTimeout(g), t instanceof Error || (t = new Error("" + (t || "Unknown XMLHttpRequest Error"))), t.statusCode = 0, u(t, f) } function o() { if (!p) { var r; clearTimeout(g), r = t.useXDR && void 0 === s.status ? 200 : 1223 === s.status ? 204 : s.status; var n = f, i = null; 0 !== r ? (n = { body: e(), statusCode: r, method: y, headers: {}, url: d, rawRequest: s }, s.getAllResponseHeaders && (n.headers = l(s.getAllResponseHeaders()))) : i = new Error("Internal XMLHttpRequest Error"), u(i, n, n.body) } } var u = t.callback; if ("undefined" == typeof u) throw new Error("callback argument missing"); u = h(u); var f = { body: void 0, headers: {}, statusCode: 0, method: y, url: d, rawRequest: s }, s = t.xhr || null; s || (s = t.cors || t.useXDR ? new a.XDomainRequest : new a.XMLHttpRequest); var c, p, g, d = s.url = t.uri || t.url, y = s.method = t.method || "GET", v = t.body || t.data || null, w = s.headers = t.headers || {}, m = !!t.sync, b = !1; if ("json" in t && (b = !0, w.accept || w.Accept || (w.Accept = "application/json"), "GET" !== y && "HEAD" !== y && (w["content-type"] || w["Content-Type"] || (w["Content-Type"] = "application/json"), v = JSON.stringify(t.json))), s.onreadystatechange = r, s.onload = o, s.onerror = n, s.onprogress = function () { }, s.ontimeout = n, s.open(y, d, !m, t.username, t.password), m || (s.withCredentials = !!t.withCredentials), !m && t.timeout > 0 && (g = setTimeout(function () { p = !0, s.abort("timeout"); var t = new Error("XMLHttpRequest timeout"); t.code = "ETIMEDOUT", n(t) }, t.timeout)), s.setRequestHeader) for (c in w) w.hasOwnProperty(c) && s.setRequestHeader(c, w[c]); else if (t.headers && !i(t.headers)) throw new Error("Headers cannot be set on an XDomainRequest object"); return "responseType" in t && (s.responseType = t.responseType), "beforeSend" in t && "function" == typeof t.beforeSend && t.beforeSend(s), s.send(v), s } function f() { } var s = e(17), h = e(26), c = e(5), l = e(31), p = e(2); t.exports = a, a.XMLHttpRequest = s.XMLHttpRequest || f, a.XDomainRequest = "withCredentials" in new a.XMLHttpRequest ? a.XMLHttpRequest : s.XDomainRequest, n(["get", "put", "post", "patch", "head", "delete"], function (t) { a["delete" === t ? "del" : t] = function (r, e, n) { return e = o(r, e, n), e.method = t.toUpperCase(), u(e) } }) }, function (t, r) { t.exports = function () { return "undefined" != typeof window.DOMParser ? function (t) { var r = new window.DOMParser; return r.parseFromString(t, "application/xml") } : "undefined" != typeof window.ActiveXObject && new window.ActiveXObject("Microsoft.XMLDOM") ? function (t) { var r = new window.ActiveXObject("Microsoft.XMLDOM"); return r.async = "false", r.loadXML(t), r } : function (t) { var r = document.createElement("div"); return r.innerHTML = t, r } }() }]);